
七大原则：

单一职责原则：一个类负责一项职责

里氏替换原则：继承与派生的规则

依赖倒置原则：高层不依赖底层，细节依赖抽象，针对接口编程
  
接口抽离原则：单一接口，细化接口，接口方法尽量少

迪米特法则：低耦合，高内聚

开闭原则：类、模块、函数对扩展开放，对修改关闭

组合/聚合复用原则：尽量使用组合和聚合，少用继承来达到复用



三大类：

创建型模式：工厂方法、抽象工厂、单例、建造者、原型

结构型模式：适配器、装饰器、代理、外观、桥接、组合、享元

行为型模式：策略、模板方法、观察者、迭代、责任链、命令、备忘录、状态、访问者、中介者、解析器


工厂模式：定义一个用于创建对象的接口，并控制返回对应类的实例；工厂方法》抽象工厂

原型模式：通过复制一个现有对象来生成新的对象，而不是通过实例化方式。复制对象机制 clone()

构建模型：builder 将类的构建逻辑转移到类的实例化外部，将一个复杂对象的创建与它的表示分离;使用场景：复杂类

单例模型：懒汉模式（线程安全、线程不安全）、饿汉模式


适配器：adapter 将一个类的接口转换成客户希望的接口  目标角色  被适配角色  适配器  
		类适配器 组合适配  应用 springMVC controller的分发  开闭原则  需求变化 新旧接口兼容适配
		在架构的时候要考虑

装饰器：decrator 包装器 wrapper  动态扩展功能  构件角色 装饰角色  继承关系的替代方案  java  io流
		装饰类和被装饰类拥有共同的超类
		在重构的时候 需求变更的时候考虑到
		
代理模式：对某些对象由于某些原因无法履行日常职责：加载时间过长、有的对象运行在其他计算机上、需要拦截转发
		通过代理来控制对该对象的访问
		
		静态代理：实现共同的超类   为了添加额外功能时代理模式和装饰模式一样
		动态代理：不需要实现共同超类 采用反射机制 限制：只能为接口创建代理实例
		cglib代理：aop  运行时动态生成一个被代理类的子类，子类重写所有被代理类的非final方法，在子类中采用方法拦截技术拦截所有父类方法的调用，顺序切入逻辑
		实现MethodInterceptor  通过Enhancer生成代理子类
		
		aop:  aspect  joinpoint  advice(around/before/after/throws) pointcut  targetObj  aopProxy
		
外观模式

桥接模式： 接口与实现分离  jdbc  加载驱动  获取链接

	

	

